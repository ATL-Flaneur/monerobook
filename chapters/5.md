# Chapter 5

# A deep dive into Monero & cryptography

Since long before the birth of computers, mathematics and cryptography have been at the center of communication and information exchange. While simple ciphers have been around since Caesar's time, modern cryptography was born during the World Wars for encrypting important and confidential messages. Initially, governments and militaries funded classified cryptography research to identify protocols for protecting state secrets.

Now, cryptography is no longer limited to spies and militaries; it forms the backbone of communication and security in the internet era, and is widely studied by academic and industry researchers scattered across the globe.

Today, cryptography is a ubiquitous behind-the-scenes tool that enables security, management, communication, and many of the connections that improve our day-to-day lives. For example, consider the invention of Secure Socket Layer (SSL, deprecated in favor of TSL), which is based on cryptographically signing the content. Hospitals, banks, governments, and businesses all protect your data with cryptography. 

This chapter discusses how cryptographic tools can be applied to a decentralized financial database to give rise to cryptocurrencies, especially Monero.

## 5.1 Math fundamentals

Here is a brief introduction/recap of several mathematical principles that are at the core of cryptography.

### 5.1.1 Euclidean Division (A/B)

Dividing any number A by another B, written as A/B or A÷B returns an answer that can either be written as a quotient with a remainder, or as a decimal alone. 

Generally: 
A/B = q with remainder r
For example:
12/4 = 3 with remainder 0, which can be written 3.0 
in decimal form
13/4 = 3 with remainder 1, which can be written 3.25 
in decimal form 
27/5 = 5 with remainder 2, which can be written 5.4 
in decimal form

### 5.1.2 Prime numbers

A prime number is any integer (whole number) that is not divisible by any integer besides '1' and itself. For example: 

**20 is not prime** because it is divisible by 2, 4, 5, and 10, resulting in whole numbers
	e.g. 20 ÷ 4 = 5
	- or -
         20 ÷ 10 = 2
7 is prime because any integer that you divide it by will not yield a whole number
e.g. 7 ÷ 3 = 2.3333

Some example prime numbers include 3, 5, 7, 11, 13, 97, 223, 997, 3413, 4421, 17837,  145601, 428567, 1171967, and even much larger numbers like 2074722246773485207821695222107608587480996474721117292752992589912196684750549658310084416732550077 or the twin primes 2,996,863,034,895  × 2^1,290,000 ± 1, which have over 350,000 digits each!

### 5.1.3 Modular arithmetic

Modular arithmetic describes numbers that wrap around a particular integer. An intuitive example is the 12-hour clock. If you stay up for 5 hours past 11:00 PM, you would not encounter 16:00 PM o'clock! Instead, at midnight, the time wraps around to zero (so 5 hours past 11:00 PM is 4:00 AM the next day).

Given any two positive numbers, A (the dividend) and B (the divisor),

A modulo B =  the remainder r from A/B. 

In the context of clocks, staying up 5 hours past 11:00 PM could be represented as:

(11:00 PM + 5 hours) mod 12 = …
        = 16:00 mod 12
        = 4:00 (AM)

### 5.1.4 Integer representation

Integers can be represented in many different encodings, several of which are encountered frequently in computer science.

Most people are quite familiar with the base-10 “decimal” system, which represents numbers using 10 characters: 
0,1,2,3,4,5,6,7,8,9.

“Hex” encoding adds 6 extra characters, for a base-16 set: 
0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f.

The integer written as 11719682 in base-10 can be expressed as B2D402 in base-16. Note that a larger character set requires fewer digits (shorter strings) to express the same number.

Computers “think” in base-2, using only the characters “0” and “1.” This is called binary and the number 11719682 (base-10) would be represented as 101100101101010000000010.

Monero prints final addresses and keys in base-58, which uses Arabic numerals and most of the Latin character set (both uppercase and lowercase). It is similar to another scheme called Base64, however it has been modified to avoid numbers and letters that might look ambiguous when printed. Monero uses this format, strictly for the convenience of human users, who often must manually read or transcribe long addresses.

The base-58 alphabet is:
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

Note: Zero (0) along with the letters I (uppercase i), O (uppercase o), and l (lowercase L) are not present in this Base58 alphabet due to their ambiguity with each other.

### 5.1.5 Elliptic curves

#### 5.1.5.1 General introduction

Elliptic curves are defined as the set of 2-dimensional (x, y) points that satisfy an equation:

y^2=x^3+ax+b.

For example, with fixed coefficients a = 2 and b = 3, this equation becomes

y^2=x^3+2x+3,

which is satisfied by many pairs of points such as: 

x = 3 and y = 6
x = 3 and y = -6
x = -1 and y = 0.

#### 5.1.5.2 Ed25519 Twisted Edwards

Monero uses a particular Twisted Edwards elliptic curve for cryptographic operations, Ed25519, which is the birational equivalent of the Montgomery curve Curve25519.

The ed25519 curve can be expressed algebraically as

- x^2 + y² = 1 − (121665/121666) x² y².

Thinking back to our general elliptic curve equation, this Twisted Edwards is a special case using the parameters:

 a = -1 and b = 121665/121666.

Recently, it has become clear that a NIST-backed PRNG (Pseudo-random Number Generator Algorithm) is flawed, and contains a potential backdoor. Since the NIST4 standard algorithms have had recent issues, and the Twisted Edwards curve was selected to address many concerns held by the cryptography community. 

Seen from a broader perspective, curves selected by the NIST are also implicitly supported by the NSA. These endorsements are viewed suspiciously by the cryptography and cryptocurrency communities due to previous incidents when the NSA used their authority over NIST to weaken algorithms suggested by the latter.

Twisted Edwards curve Ed25519 is not subject to any patents, and the team behind it has developed and adapted basic cryptographic algorithms with efficiency in mind. This curve is currently believed to be secure.

#### 5.1.5.3 Elliptical operations

Elliptic curve point addition and scalar multiplication are fundamental operations for elliptic curve cryptography schemes. It's helpful to have a basic understanding of these concepts before we dive into the mechanics of Monero's calculations.

Elliptic curve point addition operates differently than the typical addition encountered in everyday arithmetic. To add two points together on an elliptic curve you must find the line between those two points and then find the point at which the curve intersects with that line. That point is then reflected over the x-axis to arrive at the final point.

When adding a point to itself, known as point doubling, you must find the tangent line to the starting point to get to the point at which that tangent line intersects with the curve. That point is then reflected over the x-axis to arrive at the final point.

Scalar multiplication utilizes both a point on the curve and an integer. To multiply a point, P, by an integer, S, the point is added to itself S times. Many cryptographic schemes, such as those employed by Monero, use a common base point on the elliptic curve as a generator point to generate public keys from private keys.

When the curve generator point is added to itself many times, the resulting point cannot be used to determine how many times the operation occurred. This problem is often referred to as the elliptic curve discrete logarithm problem. This kind of scalar multiplication is considered a one-way function, since reversing the operation is so difficult.

## 5.2 Cryptography basics

Monero is the leading secure and untraceable cryptocurrency thanks to its unique privacy-oriented cryptographic features, which we'll explore more thoroughly in this chapter. This is one of the more technical chapters of the book, due to the mathematical nature of cryptography. More complex techniques are built upon simple principles known as cryptographic primitives.

A cryptographic primitive is an algorithm that serves as the building block for cryptographic protocols. Monero employs a wide variety of cryptographic primitives for various uses, some of which we covered conceptually in chapters 3 and 4. Monero's intentional approaches to privacy and (ASIC-resistant) proof of work require more sophisticated cryptographic tools than those used by many other cryptocurrencies.

### 5.2.1 Symmetric and asymmetric cryptography

For encrypting data, algorithms can be characterized as symmetric or asymmetric depending on what type of keys are used.

Symmetric encryption requires the participants to share a secret, for example you encrypt a message by the password “hunter2” and the recipient uses the password “hunter2” to decrypt it. To communicate in this way, both parties must have agreed on the shared (symmetric) secret ahead of time. This practical issue limits the utility of symmetric encryption for many applications.

Asymmetric encryption allows two parties to interact securely without sharing a particular secret. This type of cryptography is woven into the framework of internet security, end-to-end messengers, and cryptocurrencies.

Bitcoin uses asymmetric encryption with two keys:

* private key - for signing transactions and for decrypting data
* public key - for signature verification and encrypting data

Monero's more complex cryptographic framework requires four keys:

* public view key - used to verify the validity of addresses
* private view key - used for viewing data such as the balance, 	fees and transactions amounts (the view key cannot create or sign transactions)
* public spend key - another public key for transaction verification
* private spend key - used for signing transactions, i.e. sending moneroj

Your public Monero address is a direct representations of the pair of public keys, whereas Bitcoin (and clones) use a hash of their single public key.  EdDSA keys (both private and public) are 256 bits long, or 64 hexadecimal characters. Not every 256-bit integer is a valid EdDSA scalar (private key); it must be less than the “curve order” described with the equation in the Ed25519 function section. 

### 5.2.2 Hashing

Chapter 4 discussed the concept of hashing and how its uses range from confirming data fidelity to distributing rewards in Proof of Work. Example hashes are shown in the cryptography section toward the end of Chapter 4.

Selecting a good hashing algorithm is crucial for generating addresses and keys in a secure way. If two different inputs produce the same hash output, this is known as a collision. Hashes are commonly used as an identifier in blockchain systems, relying on their effective uniqueness. Furthermore, a collision during seed generation would lead to multiple individuals with the same keys and addresses; obviously this would be extremely problematic!

Monero uses the CryptoNight PoW system, which employs a special CryptoNote hash algorithm, which is build on the Keccak hash. The Keccak algorithm won a NIST competition to be designated SHA3, and is designed by non-NSA engineers. Monero uses the Keccak-256 hashing function with 32-byte output for both transaction and block hashing.

5.2.3 Monero pseudorandom number generation (PRNG)
When users and computers are creating new keys, it is crucial that they find new keys that others cannot guess. This is actually a very difficult task, since both hardware and software are typically designed to favor reproducibility. If the computer generates randomness in a predictable way, then the output can be ostensibly random but somewhat easier to guess.

For example consider a PRNG that simply shuffles the digits of the current time to make a 4-digit key. So at “10:34” it might output “0413” or “1403” or “0134” … If you wanted to keep the output key secret, this would be a terrible method for a few reasons:

An attacker who knows that you made your key when you got to work around 12:45 AM would know that the digits “1” and “2” appear, which narrows the choices down to significantly fewer options.

There are no HH:MM times of day with three “9”s. In fact, there are no times with any three digits chosen from {6,7,8,9} since 17:89 h, 18:78 h, etc are impossible times. This rule eliminates many 4-digit pins, leaving the attacker to guess from a much smaller pool.

The above clock-based random number generator is awful because using the time of day as an initial seed is predictable. The initial seed should be much more difficult for an attacker to guess. Good random number generators introduce lots of entropy to make their outputs unpredictable. Simply shuffling 4 digits does not introduce much entropy, another reason that our PRNG above would be insecure.

When generating wallets, the user's operating system provides the initial seed / entropy source. Monero then repeatedly applies the Keccak hashing function, to lead to an unpredictable and non-reproducible output. Each round of hashing produces an output that is used as the input for the next hash.

## 5.3 Generating Monero keys and addresses

### 5.3.1 Picking a seed

In chapter 2 we talked about the heart of your wallet: its seed. Your wallet generates this secret that is used to derive all of your keys, and access/spend your funds. In that overview, we simply considered the 25-word seed mnemonic.  

Behind the scenes, a seed is an unique 256-bit integer from which keys and addresses are derived, for example:

112699108505435943726051051450940377552177626778909564691673845134467691053980
These are often represented as a 64-digit base-16 number, for example:

f9296f587419f1cdede67de160fca14d1069ecaa4c52f012af031eeA09ee039c

(For mnemonic-style keys, this representation of the seed is actually just the private spend key itself!)

Writing down either of the above key styles would be quite difficult, and most people would be prone to make at least one mistake. Conversion to a seed mnemonic phrase is another step included only for human interpretability and usability. The mnemonic phrase essentially converts the the above 256-bit number into to a 24-digit (24-word) base-1626 “number” (since there are 1626 words in the seed dictionary). This representation of the long seed strings is much easier to read: 

lamb hexagon aces acquire twang bluntly argue when unafraid awning academy nail threaten sailor palace selfish cadets click sickness juggled border thumbs remedy ridges border

When your wallet presents the 24-word seed, it adds a 25th word that functions as a checksum, which allows later detection of typos or mistakes. Monero's mnemonic method encodes with a minimum 4:3 ratio. In other words, four bytes creates three words, plus one checksum word; eight bytes creates six words, plus one checksum word; and so on.

The private view key is derived by hashing the seed with Keccak-256, producing a second 256-bit integer, which is then sent to the function called sc_reduce32 to ensure that it is compatible with the elliptic curve. The seeds created by this method will always be valid scalars as they are sent to sc_reduce32 first. 

5.3.2 Key derivation
5.3.2.1 All keys

The Monero seed described above is actually your secret spend key, from which all other keys are derived. The secret view key is the reduced hash of your secret spend key, converted to a valid scalar for the ed25519 curve.

These two private keys are multiplied by the generator point to yield the two public keys for your wallet (public spend and public view). This method for derivating keys is referred to as the deterministic method.

5.3.2.2 View-only wallets

You can grant view-only access to a Monero account by setting up a wallet with your secret view key, but NOT the secret spend key. These view-only wallets can see all incoming transactions, but cannot spend moneroj or see outgoing transactions.

There are several situations in which it is useful to check incoming transactions without send access. For instance, individuals with cold wallets can use the view key to check that funds arrived, while keeping their secret spend key safely sequestered away. Likewise, developers can build systems that can detect and respond to incoming payments, without needing to have the ability to move those funds.

This feature is especially valuable for charities, which can share their view key to ensure transparency and accountability around donations. If you make a donation to the a public address, you can use the view key to verify that the charity received your funds.

For example, consider the the main Monero donation address: 
44AFFq5kSiGBoZ4NMDwYtN18obc8AemS33DBLWs3H7otXft3XjrpDt QGv7SqSsaBYBb98uNbr2VBBEt7f2wfn3RVGQBEP3A. 

Since stealth addresses prevent that public address from being recorded or searchable on the blockchain, the community also publishes the view key (f359631075708155cc3d92a32b75a7d02a5dcf27756707b47a2b31b21c389501) so that the public can review donation activity.

Since anybody with the view key can see the total amount that a wallet has received, a transparent charity that has been gifted 100 XMR cannot divert 90 XMR and claim that they only received 10 XMR. This functionality is especially valuable for crowdfunding situations where a certain donation threshold must be reached.

The inability to see outgoing transactions from a view-only wallet is a feature, not a bug! If the outgoing transactions were made public, it would reveal when an output has been spent. This would be very problematic, since ring signatures rely on spend state ambiguity. Suppose a charity reveals when an output is spent; all appearances in future (and previous) ring signatures can be identified as decoys. Not exposing outgoing transactions is thus necessary for maintaining the integrity of overall network privacy.

### 5.3.3 Address generation

A Monero wallet's standard address is composed of the two public keys (the public spend key + public view key) derived in the last section. It also contains a checksum and a network byte which identifies both the network and the address type.
 
#### 5.3.3.1 Network byte

The network byte is used differentiating between various cryptocurrencies and networks. CryptoNote coins specify the appropriate values in the file src/CryptoNote_config.h, for example

uint64_t const CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 18;

Monero's main network uses '18' to indicate a primary address (this is why Monero primary addresses begin with a '4,' which is the ASCII  representation).  Monero developers use the testnet and stagenet, which have their own unique network bytes:

Name | Code Value | ASCII value
-- | -- | --
Main net primary address |	18 |	4
Main net subaddress	| 42 |	8
Test net primary address |	53 |	9
Test net subaddress |	63	| B
Stage net primary address	| 26	| 5
Stage net subaddress	| 36	| 7

#### 5.3.3.2 Concatenated public keys

The public spend key and public view key are concatenated and appended to the network byte, to produce the raw address (everything except the checksum). While this address is still in a raw format, it contains all of the key information: keys for crafting transactions and network metadata to ensure that transactions are announced to the correct network.

#### 5.3.3.3 Checksum

Since Monero transactions are non-reversible, it's crucial to send payments to the right address! To help avoid typos and minor mistakes, the address includes a checksum. If the sender makes a typo or doesn't capture the whole address, the checksum will not match, indicating that the string entered is not a valid address.

This checksum is generated by Keccak hashing the address information collected in the previous section. The hash digest is shortened to the first 4 bytes, and used as the checksum.

5.3.3.4 Bring it all together: address finalization

Lastly, the network byte, keys, and checksum are concatenated according to Monero specification:
